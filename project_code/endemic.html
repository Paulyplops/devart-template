
<!DOCTYPE html>
<html>
<head>
<title>Experiment 4</title>
<script type="text/javascript" src="jquery-2.1.0.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript">


$(document).ready( function()
{
} );


function createAndSetupTexture(gl) {
  var texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);

  // Set up texture so we can render any size image and so we are
  // working with pixels.
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

  return texture;
}

$(window).load( function()
{
  var w = $(window).width();
  var h = $(window).height();

  // w = 255;
  // h = 255;

  // Make an off-screen canvas used to seed the simulation.
  // The concentration of the two chemicals is represented by 
  // the red and green channels.

  var offscreenCanvas = document.createElement('canvas');
  offscreenCanvas.width = w;
  offscreenCanvas.height = h;

  var ctx = offscreenCanvas.getContext("2d");

  // Uniform red.
  ctx.fillStyle = "rgba( 255, 0, 0, 1.0 )";  
  ctx.fillRect( 0, 0, w, h );  

  // Random red.
  if( false )
  {

    var imageData = ctx.createImageData( w, h );

    for( var i = 0; i < w; ++i )
    {
      for( var j = 0; j < h; ++j )
      {
         var p = ( j * w + i ) * 4;

         imageData.data[ p + 0 ] = Math.random() * 255;
         imageData.data[ p + 1 ] = 0;
         imageData.data[ p + 2 ] = 0;
         imageData.data[ p + 3 ] = 255;
      }
    }

    ctx.putImageData( imageData, 0, 0 ); 
  }

  // Random green blobs.
  ctx.fillStyle = "rgba( 255, 255, 0, 1.0 )";
  var blobs = w / 50;
  var blobRadius = 2;
  for( var i = 0; i < blobs; ++i ) {
    ctx.beginPath();
    ctx.arc( Math.random() * w, Math.random() * h, blobRadius, 0, 2 * Math.PI);
    ctx.fill();
  }

  // Set the width and height of the display canvas to the 
  // entire window.

  $("#canvas").width( w );
  $("#canvas").height( h );
  var canvas = $('#canvas')[0];
  canvas.width = w;
  canvas.height = h;
 
  // Set up WebGL.

  var gl = getWebGLContext(canvas);
  if (!gl) {
    return;
  }

  // setup GLSL program
  vertexShader = createShaderFromScriptElement(gl, "2d-vertex-shader");
  fragmentShader = createShaderFromScriptElement(gl, "2d-fragment-shader");
  program = createProgram(gl, [vertexShader, fragmentShader]);
  gl.useProgram(program);

  // look up where the vertex data needs to go.
  var positionLocation = gl.getAttribLocation(program, "a_position");
  var texCoordLocation = gl.getAttribLocation(program, "a_texCoord");

  // Provide texture coordinates for the rectangle.
  var texCoordBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      0.0,  0.0,
      1.0,  0.0,
      0.0,  1.0,
      0.0,  1.0,
      1.0,  0.0,
      1.0,  1.0]), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(texCoordLocation);
  gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

  // Create a texture and put the image in it.
  var originalImageTexture = createAndSetupTexture(gl);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, ctx.getImageData( 0, 0, w, h ) );

  // create 2 textures and attach them to framebuffers.
  var textures = [];
  var framebuffers = [];
  for (var ii = 0; ii < 2; ++ii) {
    var texture = createAndSetupTexture(gl);
    textures.push(texture);

    // make the texture the same size as the image
    gl.texImage2D(
        gl.TEXTURE_2D, 0, gl.RGB, w, h, 0,
        gl.RGB, gl.UNSIGNED_BYTE, null);

    // Create a framebuffer
    var fbo = gl.createFramebuffer();
    framebuffers.push(fbo);
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

    // Attach a texture to it.
    gl.framebufferTexture2D(
        gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  }

  // Lookup uniforms.
  // Housekeeping.
  var resolutionLocation = gl.getUniformLocation(program, "u_resolution");
  var textureSizeLocation = gl.getUniformLocation(program, "u_textureSize");

  // Parameters for the simulation.
  var kernelLocation = gl.getUniformLocation(program, "u_kernel[0]");
  var diffusionLocation = gl.getUniformLocation(program, "u_diffusion");
  var killLocation = gl.getUniformLocation(program, "u_kill");
  var feedLocation = gl.getUniformLocation(program, "u_feed");
  var timeDeltaLocation = gl.getUniformLocation(program, "u_timeDelta");
  var spaceDeltaLocation = gl.getUniformLocation(program, "u_spaceDelta");

  var laplacianKernel = [
      0.05, 0.2, 0.05,
      0.2,   -1,  0.2,
      0.05, 0.2, 0.05
  ]

  var laplacianSimpleKernel = [
      0.0,  0.25,  0.0,
      0.25,   -1, 0.25,
      0.0,  0.25,  0.0
  ]

  // The laplacian.
  gl.uniform1fv( kernelLocation, laplacianKernel );

  // The diffusion is the rates of the two chemicals. ( D_R, D_G )
  gl.uniform2f( diffusionLocation, 1.0, 0.5 );

  // The rate that G dies off.
  gl.uniform1f( killLocation, 0.062 );

  // The rate that R is fed into the system.
  gl.uniform1f( feedLocation, 0.037 );

  // Time-step
  gl.uniform1f( timeDeltaLocation, 5.0 );
  
  // Space delta.
  gl.uniform1f( spaceDeltaLocation, 0.2 );

  // set the resolution
  gl.uniform2f(resolutionLocation, canvas.width, canvas.height);

  // set the size of the image
  gl.uniform2f(textureSizeLocation, w, h);

  // Create a buffer for the position of the rectangle corners.
  var buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

  // Set a rectangle the same size as the image.
  setRectangle(gl, 0, 0, w, h);
  

  function setFramebuffer(fbo, width, height) {
    // make this the framebuffer we are rendering to.
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

    // Tell webgl the viewport setting needed for framebuffer.
    gl.viewport(0, 0, width, height);
  }

  // Display Program - - - - - - - - - - - -

  vertexShaderDisp = createShaderFromScriptElement(gl, "2d-vertex-shader");
  fragmentShaderDisp = createShaderFromScriptElement(gl, "2d-fragment-shader-disp");

  programDisp = createProgram(gl, [vertexShaderDisp, fragmentShaderDisp]);
  gl.useProgram( programDisp );

  {
    // look up where the vertex data needs to go.
    var positionLocation = gl.getAttribLocation(programDisp, "a_position");
    var texCoordLocation = gl.getAttribLocation(programDisp, "a_texCoord");

    var resolutionLocationDisp = gl.getUniformLocation(programDisp, "u_resolution");

    // Provide texture coordinates for the rectangle.
    var texCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        0.0,  0.0,
        1.0,  0.0,
        0.0,  1.0,
        0.0,  1.0,
        1.0,  0.0,
        1.0,  1.0]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(texCoordLocation);
    gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

    // Create a buffer for the position of the rectangle corners.
    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    gl.uniform2f(resolutionLocationDisp, canvas.width, canvas.height);

    // Set a rectangle the same size as the image.
    setRectangle(gl, 0, 0, w, h);
  }

  // Do Work - - - - - - - - - - - - -

  gl.useProgram( program );
  // start with the original image
  gl.bindTexture(gl.TEXTURE_2D, originalImageTexture);

  function Anim( time )
  {
    // Why doesn't this work for rate 1?
    var rate = 2;
    for( var i = 0; i < rate; ++i )
    {
      // Setup to draw into one of the framebuffers.
      setFramebuffer(framebuffers[i % 2], w, h);

      // Tell the shader the resolution of the framebuffer.
      gl.uniform2f(resolutionLocation, w, h);

      // Draw the rectangle.
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // for the next draw, use the texture we just rendered to.
      gl.bindTexture( gl.TEXTURE_2D, textures[i % 2] );
    }


    gl.useProgram( programDisp );
    gl.bindTexture( gl.TEXTURE_2D, textures[rate % 2] );
    // finally draw the result to the canvas.
    setFramebuffer(null, canvas.width, canvas.height);

    gl.uniform2f(resolutionLocationDisp, w, h);
    // Draw the rectangle.
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    gl.useProgram( program );
    requestAnimFrame( Anim );
  }

  var lastTime = new Date().getTime();
  requestAnimFrame( Anim );
});


// Fills the buffer with the values that define a rectangle.
function setRectangle( gl, x, y, width, height ) {
  var x1 = x;
  var x2 = x + width;
  var y1 = y;
  var y2 = y + height;
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
     x1, y1,
     x2, y1,
     x1, y2,
     x1, y2,
     x2, y1,
     x2, y2]), gl.STATIC_DRAW);
}




</script>


<!-- vertex shader -->
<script id="2d-vertex-shader" type="x-shader/x-vertex">
attribute vec2 a_position;
attribute vec2 a_texCoord;

uniform vec2 u_resolution;

varying vec2 v_texCoord;

void main() {
   // convert the rectangle from pixels to 0.0 to 1.0
   vec2 zeroToOne = a_position / u_resolution;

   // convert from 0->1 to 0->2
   vec2 zeroToTwo = zeroToOne * 2.0;

   // convert from 0->2 to -1->+1 (clipspace)
   vec2 clipSpace = zeroToTwo - 1.0;

   gl_Position = vec4(clipSpace, 0, 1);

   // pass the texCoord to the fragment shader
   // The GPU will interpolate this value between points.
   v_texCoord = a_texCoord;
}

</script>
<!-- fragment shader -->
<script id="2d-fragment-shader" type="x-shader/x-fragment">
precision mediump float;

// our texture
uniform sampler2D u_image;
uniform vec2 u_textureSize;

uniform float u_kernel[9];
uniform vec2 u_diffusion;
uniform float u_kill;
uniform float u_feed;
uniform float u_timeDelta;
uniform float u_spaceDelta;

// the texCoords passed in from the vertex shader.
varying vec2 v_texCoord;

void main() {
  vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;

  // Laplacian is difference between the this sample and the average neighbour.
  vec4 laplacian =
     texture2D(u_image, v_texCoord + onePixel * vec2(-1, -1)) * u_kernel[0] +
     texture2D(u_image, v_texCoord + onePixel * vec2( 0, -1)) * u_kernel[1] +
     texture2D(u_image, v_texCoord + onePixel * vec2( 1, -1)) * u_kernel[2] +
     texture2D(u_image, v_texCoord + onePixel * vec2(-1,  0)) * u_kernel[3] +
     texture2D(u_image, v_texCoord + onePixel * vec2( 0,  0)) * u_kernel[4] +
     texture2D(u_image, v_texCoord + onePixel * vec2( 1,  0)) * u_kernel[5] +
     texture2D(u_image, v_texCoord + onePixel * vec2(-1,  1)) * u_kernel[6] +
     texture2D(u_image, v_texCoord + onePixel * vec2( 0,  1)) * u_kernel[7] +
     texture2D(u_image, v_texCoord + onePixel * vec2( 1,  1)) * u_kernel[8] ;

  vec4 sample = texture2D(u_image, v_texCoord );

  float r = sample.r 
            + ( u_diffusion.r * laplacian.r * u_spaceDelta
            - sample.r * sample.g * sample.g
            + u_feed * ( 1.0 - sample.r ) ) * u_timeDelta;
  float g = sample.g 
            + ( u_diffusion.g * laplacian.g * u_spaceDelta 
            + sample.r * sample.g * sample.g 
            - ( u_kill + u_feed ) * sample.g ) * u_timeDelta;
  float b = sample.b;

  gl_FragColor = vec4( r, g, b, 1.0);
}

</script>

<!-- fragment shader -->
<script id="2d-fragment-shader-disp" type="x-shader/x-fragment">
precision mediump float;

// our texture
uniform sampler2D u_image;

// the texCoords passed in from the vertex shader.
varying vec2 v_texCoord;

void main() {
  vec4 sample = texture2D(u_image, v_texCoord );
  float v = sample.g * 3.0;
  gl_FragColor = vec4( v, v, v, 1.0);
}

</script>


    <style type="text/css">
      canvas { 
        border: 0px; 
      }
      html,body, canvas {
        margin: 0px;
        padding: 0px;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" width="200px" height="200px"></canvas>
  </body>
</html>
